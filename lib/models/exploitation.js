import {nanoid} from 'nanoid'
import mongo, {ObjectId} from '../util/mongo.js'
import {validateChanges, validateCreation} from '../validation/exploitation-validation.js'
import * as storage from './internal/in-memory.js'
import createHttpError from 'http-errors'

export async function getExploitationsFromPointId(idPoint) {
  return mongo.db.collection('exploitations').find(
    {id_point: idPoint, deletedAt: {$exists: false}}
  ).toArray()
}

export async function getExploitation(idExploitation) {
  return mongo.db.collection('exploitations').findOne(
    {id_exploitation: idExploitation, deletedAt: {$exists: false}}
  )
}

export async function createExploitation(payload) {
  const exploitation = validateCreation(payload)

  const point = await mongo.db.collection('points_prelevement').findOne({id_point: payload.id_point})

  if (!point) {
    throw createHttpError(400, 'Ce point de prélèvement est introuvable.')
  }

  const preleveur = await mongo.db.collection('preleveurs').findOne({id_preleveur: payload.id_preleveur})

  if (!preleveur) {
    throw createHttpError(400, 'Ce préleveur est introuvable.')
  }

  if (exploitation.documents.length > 1) {
    for (const document of exploitation.documents) {
      document.id_document = nanoid()
    }
  }

  if (exploitation.regles.length > 1) {
    for (const regle of exploitation.regles) {
      regle.id_regle = nanoid()
    }
  }

  if (exploitation.modalites.length > 1) {
    for (const modalite of exploitation.modalites) {
      modalite.id_modalite = nanoid()
    }
  }

  exploitation._id = new ObjectId()
  exploitation.id_exploitation = nanoid()
  exploitation.createdAt = new Date()
  exploitation.updatedAt = new Date()

  await mongo.db.collection('exploitations').insertOne(exploitation)

  return exploitation
}

export async function updateExploitation(idExploitation, payload) {
  const changes = validateChanges(payload)

  if (Object.keys(changes).length === 0) {
    throw createHttpError(400, 'Aucun champ valide trouvé.')
  }

  changes.updatedAt = new Date()

  const exploitation = await mongo.db.collection('exploitations').findOneAndUpdate(
    {id_exploitation: idExploitation, deletedAt: {$exists: false}},
    {$set: changes},
    {returnDocument: 'after'}
  )

  if (!exploitation) {
    throw createHttpError(404, 'Cette exploitation est introuvable.')
  }

  return exploitation
}

export async function deleteExploitation(exploitationId) {
  return mongo.db.collection('exploitations').findOneAndUpdate(
    {id_exploitation: exploitationId, deletedAt: {$exists: false}},
    {$set: {
      deletedAt: new Date(),
      updatedAt: new Date()
    }},
    {returnDocument: 'after'}
  )
}

export async function getDocumentFromExploitationId(idExploitation) {
  return storage.exploitationsDocuments
    .filter(ed => ed.id_exploitation === idExploitation)
    .map(ed => storage.indexedDocuments[ed.id_document])
}

export async function getReglesFromExploitationId(idExploitation) {
  return storage.exploitationsRegles
    .filter(r => r.id_exploitation === idExploitation)
    .map(r => storage.indexedRegles[r.id_regle])
}

export async function getModalitesFromExploitationId(idExploitation) {
  return storage.exploitationModalites
    .filter(m => m.id_exploitation === idExploitation)
    .map(m => storage.indexedModalitesSuivis[m.id_modalite])
}

export async function getDocumentFromRegleId(idRegle) {
  const regle = storage.indexedRegles[idRegle]
  return storage.indexedDocuments[regle.id_document]
}

export async function getMatchingExploitation(idPoint, {idPreleveur, dateValidite} = {}) {
  if (!idPoint) {
    throw new Error('idPoint is required')
  }

  const exploitationsPoint = await getExploitationsFromPointId(idPoint)

  const candidates = exploitationsPoint.filter(exploitation => {
    if (idPreleveur && exploitation.id_preleveur !== idPreleveur) {
      return false
    }

    if (dateValidite && (exploitation.date_debut > dateValidite || exploitation.date_fin < dateValidite)) {
      return false
    }

    return true
  })

  if (candidates.length === 0) {
    return null
  }

  if (candidates.length > 1) {
    throw new Error(`Multiple exploitations found for point ${idPoint} and preleveur ${idPreleveur}`)
  }

  return candidates[0]
}
